---
layout: post
title: 「重构」关于重构（Refactoring）的一些看法和思考
date: 2020-08-22
tags: 
- 重构
- 设计模式
---

## 概要

什么是重构：在不改变代码行为的前提下，对代码进行修改，以改进程序的内部结构。 -- Martin Fowler 《重构改善既有代码的设计》

<!--more-->

## 重构的动机

虽然对代码进行重构的原因很多，但是一下这些动机是最普遍的。

* 使新代码的增加更加容易
* 改善既有代码的设计
* 对代码理解更透彻
* 提高编程的趣味性

## 重构标签

> 灵活性（flexibility）、可扩展性（extensibility）、可维护性（maintainability）
> 可读性（readability）、可理解性（understandability）、易修改性（changeability）
> 可复用（reusability）
> 可测试性（testability）
> 模块化（modularity）
> 高内聚低耦合（high cohesion loose coupling）
> 高效（high effciency）、高性能（high performance）
> 安全性（security）、兼容性（compatibility）、易用性（usability）
> 整洁（clean）、清晰（clarity）、简单（simple）、直接（straightforward）
> 少即是多（less code is more）
> 文档详尽（well-documented）、分层清晰（well-layered）
> 正确性（correctness、bug free）、健壮性（robustness）、鲁棒性（robustness）
> 可用性（reliability）、可伸缩性（scalability）、稳定性（stability）
> 优雅（elegant）、好（good）、坏（bad）
> ……

## 常用的代码质量评判标准

可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。

其中，*可维护性、可读性、可扩展性*又是提到最多的、最重要的三个评价标准。

## 面向对象思维方式

面向对象编程风格是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。

## 继承存在的问题

继承最大的问题就在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。

我们很难真正使用继承，根本原因在于，自然界中，代际之间是存在变异的，物种之间也是，而且这种变化是无法做规律化描述的，既伴随着某些功能的增加，也伴随着某些功能的弱化，甚至还有某些功能的改变。 在软件行业最早期，软件功能很贫乏，需要不断增加软件功能来满足需求，这时候继承关系能够体现软件迭代后功能增强的特点。但很快就达到瓶颈期，功能不再是衡量软件好坏的主要指标，各种差异化的体验变得更加重要，此时软件迭代时不再是单纯的功能的累加，甚至于是完全的推倒重来，编程语言上的继承关系也就随之被废弃。

我们知道继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成。比如 is-a 关系，我们可以通过组合和接口的 has-a 关系来替代；多态特性我们可以利用接口来实现；代码复用我们可以通过组合和委托来实现。所以，从理论上讲，通过组合、接口、委托三个技术手段，我们完全可以替换掉继承，在项目中不用或者少用继承关系，特别是一些复杂的继承关系。

如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。

## 类与类之间的交互关系

1. **泛化（Generalization）** 可以简单理解为继承关系

2. **实现（Realization）** 一般是指接口和实现类之间的关系。

3. **聚合（Aggregation）** 是一种包含关系，A 类对象包含 B 类对象，B 类对象的生命周期可以不依赖 A 类对象的生命周期，也就是说可以单独销毁 A 类对象而不影响 B 对象，比如课程与学生之间的关系。具体到 Java 代码就是下面这样：
   
```java
public class A {
  private B b;
  public A(B b) {
    this.b = b;
  }
}
```

4. **组合（Composition）** 也是一种包含关系。A 类对象包含 B 类对象，B 类对象的生命周期跟依赖 A 类对象的生命周期，B 类对象不可单独存在，比如鸟与翅膀之间的关系。具体到 Java 代码就是下面这样：

```java

public class A {
  private B b;
  public A() {
    this.b = new B();
  }
}
```

5. **关联（Association）** 是一种非常弱的关系，包含聚合、组合两种关系。具体到代码层面，如果 B 类对象是 A 类的成员变量，那 B 类和 A 类就是关联关系。

6. **依赖（Dependency）** 是一种比关联关系更加弱的关系，包含关联关系。不管是 B 类对象是 A 类对象的成员变量，还是 A 类的方法使用 B 类对象作为参数或者返回值、局部变量，只要 B 类对象和 A 类对象有任何使用关系，我们都称它们有依赖关系。


## 一个限流框架的易用性拓展

**易用性**方面，我们希望限流规则的配置、编程接口的使用都很简单。我们希望提供各种不同的限流算法，比如基于内存的单机限流算法、基于 Redis 的分布式限流算法，能够让使用者自由选择。除此之外，因为大部分项目都是基于 Spring 开发的，我们还希望限流框架能非常方便地集成到使用 Spring 框架的项目中。

**扩展性、灵活性**方面，我们希望能够灵活地扩展各种限流算法。同时，我们还希望支持不同格式（JSON、YAML、XML 等格式）、不同数据源（本地文件配置或 Zookeeper 集中配置等）的限流规则的配置方式。

**性能**方面，因为每个接口请求都要被检查是否限流，这或多或少会增加接口请求的响应时间。而对于响应时间比较敏感的接口服务来说，我们要让限流框架尽可能低延迟，尽可能减少对接口请求本身响应时间的影响。

**容错性**方面，接入限流框架是为了提高系统的可用性、稳定性，不能因为限流框架的异常，反过来影响到服务本身的可用性。所以，限流框架要有高度的容错性。比如，分布式限流算法依赖集中存储器 Redis。如果 Redis 挂掉了，限流逻辑无法正常运行，这个时候业务接口也要能正常服务才行。