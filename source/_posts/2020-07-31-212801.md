---
layout: post
title: 「Spring」Spring疑惑与思考
tags: 
- Spring
---

## 概述

一些关于Spring核心的疑问和思考

<!--more-->

## 1.AbstractRefreshableApplicationContext和GenericApplicationContext 父类继承了一个BeanFactory 为什么还要持有一个DefaultListableBeanFactory

|||
|:--:|:--:|
|abstract AbstractRefreshableApplicationContext | class GenericApplicationContext|
|extends↓|extends↓|
|abstract AbstractApplicationContext||
|implements↓||
|interface ConfigurableApplicationContext||
|extends↓|
|interface ApplicationContext|
|extends↓|
|interface ListableBeanFactory|
|extends↓|
|interface BeanFactory|
|||

```java
public class GenericApplicationContext extends AbstractApplicationContext implements BeanDefinitionRegistry {

	private final DefaultListableBeanFactory beanFactory;
}

public abstract class AbstractRefreshableApplicationContext extends AbstractApplicationContext {

	/** Bean factory for this context. */
	@Nullable
	private volatile DefaultListableBeanFactory beanFactory;
}
```

## 2.FactoryBean 到底是做什么用的？

Spring Bean有两种实现,普通Bean(POJO), POJO 一般是通过反射实例化。工厂Bean(FactoryBean)
实现工厂Bean的方法就是pojo继承FactoryBean,并实现他的方法,当容器通过getBean()获取bean时,返回的是实现的getObject()方法所返回的对象。
具体细节需要看源码的注解。

## 3.BeanPostProcessor接口是干什么用的？

## 4.泛型接口的注入和实例化

## 5.基类是否存在注入和实例化？

基类是抽象类或者接口无法被Spring注入，因为抽象类或者接口无法被实例化。
一般类作为基类的情况：
//TODO

## 6.贫血模型和充血模型

贫血模型（Anemic Domain Model由
MatinFowler提出）又称为失血模型，是指domain object仅有属性的getter/setter方法的纯数据类，将所有类的行为放到service层。原文他是这么说的“By pulling all the behavior out into services, however, you essentially end up with Transaction Scripts, and thus lose the advantages that the domain model can bring. ”他的原文我放上来了，英文好的同学可以看看：https://martinfowler.com/bliki/AnemicDomainModel.html 。 我觉得他有点学者气太重，这篇博客他都不知道为啥贫血模型会流行（I don't know why this anti-pattern is so common）。

## 7. 关于抽象和函数命名，有大佬说过这么一句话:

 每个优秀的程序员都知道，不应该定义一个attackBaghdad() ‘袭击巴格达‘ 的方法，而是应该把城市作为函数的参数 attack(city)。

## 8.关于使用组合还是继承的一个观点

我的观点比较极端，用接口，组合和委托代替继承。原因如下：
1. 人无法预知未来，现在比较稳定的类继承关系将来未必稳定。
2. 两种设计之间的选择耗费资源，每次都要为这个问题拿捏一下，甚至争论一下，不如把争论放在业务逻辑的实现上。
3. 相对于接口+组合+委托增加的复杂度，代码统一成接口+组合+委托带来的好处更多，利于阅读和交流，毕竟读代码的次数大于写的次数，读一种类型的代码的难度远低于读两种类型。
4. 新的编程语言让接口+组合+委托变得容易，例如Kotlin就有专门的语法糖支持，消除了很多模板代码。
5. 接口+组合+委托符合矢量化思想，那就是将物体特征分成不同的维度，每个维度独立变化。继承则是将物体分类，抽取共性，处理共性，操作的灵活性大打折扣，毕竟现实中的物体特征多，共性少。

## 9.关于单一职责，在实际项目中如何划分？

```java
public class UserInfo {
  private long userId;
  private String username;
  private String email;
  private String telephone;
  private long createTime;
  private long lastLoginTime;
  private String avatarUrl;
  private String provinceOfAddress; // 省
  private String cityOfAddress; // 市
  private String regionOfAddress; // 区 
  private String detailedAddress; // 详细地址
  // ...省略其他属性和方法...
}
```

这里的用户信息中包含了地址信息，有时候可能会觉得，地址也是用户信息的一部分，符合单一职责没毛病。
但是也需要根据实际的业务情况看，如果地址信息只是单纯的在用户信息页面做展示用，那么这么做其实也OK。

但是，如果别的模块也引用了这个地址信息，比如公司新开一个电商业务，电商需要用户的地址信息，此时的地址信息拥有做配送和个人信息也的展示两个职责，那么这个地址信息再放在用户信息类里就不太合适了，违反了单一职责原则。

如果再进一步，公司发展壮大，系统变多，所有系统都需要一个统一的用户信息，那么用户信息中的，身份证、电话、邮箱等信息被用来做身份验证，此时也不适合再放在UserInfo类中了，这些鉴权信息有多维度的职责。

一些拆分类的小技巧：

1. 如果类中的属性、方法、代码行数过多，影响代码的可读性和扩展性，此时就可以考虑拆分类了。
2. 类依赖的其他类过多，或者依赖该类的其他类过多，不符合高内聚、低耦合的设计思想，也可以考虑拆分。
3. 私有方法过多时、也可以考虑将私有方法分拆到单独的类中，定义成public，供更多的类使用，提高可复用性。
4. 
